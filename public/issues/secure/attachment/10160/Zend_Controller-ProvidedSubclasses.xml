<sect1 id="zend.controller.providedsubclasses">
    <title>Provided Subclasses</title>

    <sect2 id="zend.controller.providedsubclasses.introduction">
        <title>Introduction</title>

        <para>
            Zend Framework provides several alternatives to the default classes
            provided, including alternate request objects, routers, and response
            objects.
        </para>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.request.http">
        <title>Zend_Controller_Request_Http</title>

        <sect3 id="zend.controller.providedsubclasses.request.http.introduction">
            <title>Introduction</title>

            <para>
                <code>Zend_Controller_Request_Http</code> provides a request object
                for use in an HTTP environment. In addition to extending
                <code>Zend_Controller_Request_Abstract</code>, it proxies to a
                <code>Zend_Http_Request</code> object
            </para>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.request.http.baseurl">
            <title>Base Url and subdirectories</title>

            <para>
                <code>Zend_Controller_Request_Http</code> by proxying to
                <code>Zend_Http_Request</code> allows Zend_Controller_RewriteBase
                to be used in subdirectories. Zend_Http_Request will attempt to
                automatically detect your base URL and set it accordingly.
            </para>

            <para>
                For example, if you keep your
                <code>index.php</code> in a webserver subdirectory named
                <code>/projects/myapp/index.php</code> base URL (rewrite base)
                will be set to <code>/projects/myapp</code>. This string will
                then be stripped from the beginning of the path before
                calculating any route matches. This frees one from the necessity
                of prepending it to any of your routes. The route of
                <code>'user/:username'</code> will match URIs like
                <code>http://localhost/projects/myapp/user/martel</code> and
                <code>http://example.com/user/martel</code>.
            </para>

            <note>
                Automatic base URL is case sensitive, so make sure your URL
                will match a subdirectory name in a filesystem (even on Windows
                machines). If it doesn't you will get to noRoute action.
            </note>

            <para>
                Should base URL be detected incorrectly you can override it
                with your own base path with the help of the setBaseUrl()
                method of the Zend_Http_Request class. This can also be called on
                Zend_Controller_Request_Http. An example usage:
            </para>

            <programlisting role="php"><![CDATA[
/**
 * Instantiate a new Zend_Controller_Request_Http
 * class and set a custom Base URL
 */
$request = new Zend_Controller_Request_Http();
$request->setBaseUrl('/projects/myapp');

/* dispatch Request with custom base URL with Zend_Controller_Front */

$router = new Zend_Controller_RewriteRouter;
$controller = new Zend_Controller_Front;
$response = $controller->setControllerDirectory('./application/controllers')
                        ->setRouter($router)
                        ->dispatch($request);]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.rewriterouter">
        <title>Zend_Controller_RewriteRouter</title>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.introduction">
            <title>Introduction</title>
            <para>
                Zend_Controller_RewriteRouter is a new version of the framework
                router. Routing is the process of taking a URI endpoint and
                decomposing it to determine which controller and action of that
                controller, should receive the request. This definition of
                controller, action and optional parameters is packaged into a
                value object called Zend_Controller_Dispatcher_Token which is
                then processed by Zend_Controller_Dispatcher. Routing occurs
                only once: when the request is initially received and before the
                first controller is dispatched.
            </para>
            <para>
                Zend_Controller_RewriteRouter is designed to allow for
                mod_rewrite like functionality using pure php structures. It is
                very loosely based on Ruby on Rails routing and does not require
                any prior knowledge of webserver URL rewriting. It is designed
                to work with a single mod_rewrite rule (one of):
            </para>
            <programlisting role="php"><![CDATA[
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php]]></programlisting>
            <para>
            or:
            </para>
            <programlisting role="php"><![CDATA[
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 ]]></programlisting>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.usage">
            <title>Using a router</title>

            <para>
                To properly use the RewriteRouter you have to instantiate it,
                add some user defined routes and inject it into the controller.
                The following code illustrates the procedure:
            </para>

            <programlisting role="php"><![CDATA[
/* -- create a router -- */

$router = new Zend_Controller_RewriteRouter();
$router->addRoute('user', 'user/:username', array('controller' => 'user', 'action' => 'info'));

/* -- set it in a controller -- */

$ctrl = Zend_Controller_Front::getInstance();
$ctrl->setRouter($router);]]></programlisting>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.basic">
            <title>Basic Routes</title>

            <para>
                The heart of the RewriteRouter is the definition of user defined
                routes. Routes are created by calling the addRoute method of
                RewriteRouter and passing in a new instance of Zend_Controller_Router_Route:
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute('user', new Zend_Controller_Router_Route('user/:username'));]]></programlisting>

            <para>
                The first parameter is the name of the route. It is redundant at
                the moment of writing but will be used in the future in a URL
                view helper to allow for easy URL generation in your views.
                Should you need to make use of a previously configured named
                route, you can retrieve it with the getRoute method of the
                RewriteRouter.
            </para>

            <para>
                The second parameter is a route that will be matched to a URL -
                for example, the above route will match
                <code>http://example.com/user/martel</code>. The colon in a
                route marks a URL variable which will be accessible through a
                Zend_Controller_Action::_getParam method. In our example a
                parameter named username will be set to a value of 'martel'.
            </para>

            <note>
                Routes are matched in reverse order so make sure your most
                generic routes are defined first.
            </note>

            <note>
                For now the current implementation allows for use of any
                characters except a slash (/) as a variable identifier but it is
                strongly recommended that one uses only php variable friendly
                characters. In future the implementation will probably be
                altered and this may introduce bugs to your code.
            </note>

            <para>
                There are two special variables which can be used in your routes
                - 'controller' and 'action'. These special variables will be
                used to find a controller and/or an action chosen in the URL.
                The 'action' variable must always be defined either in the route
                or as a default parameter. The 'controller' variable will
                default to the IndexController if it is not defined.
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'user', new Zend_Controller_Router_Route(':controller/:action')
);]]></programlisting>

            <para>
                If you point your browser to 'http://example.com/news/latest'
                with this route defined the Zend_Controller_Dispatcher will
                invoke the latestAction of your NewsController.
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.variable-defaults">
            <title>Variable defaults</title>

            <para>
                Every variable in the route can have a default. To provide it
                you have to add a third parameter to the addRoute method. This
                third parameter is an array with keys as variable names and
                values as desired defaults.
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive', new Zend_Controller_Router_Route('archive/:year', array('year' => 2006))
);]]></programlisting>
            <para>
                What may not be clearly visible is that the above route will
                match URLs like 'http://example.com/archive/2005' and
                'http://example.com/archive'. In the latter case the variable
                year will have a value of 2006.
            </para>

            <para>
                In the above example we haven't set a controller so it will
                always result in a noRoute action of an IndexController. To make
                it usable you have to provide a valid controller and a valid
                action as a default:
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' => 2006, 'controller' => 'archive', 'action' => 'show')
);]]></programlisting>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.variable-requirements">
            <title>Variable requirements</title>

            <para>
                One can add a fourth parameter where variable requirements can
                be set. These are defined as regular expressions:
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' => 2006), array('year' => '\d+'))
);]]></programlisting>

            <note>
                Unlike Ruby on Rails, ZF RewriteRouter will match a route and
                use a default when a fourth parameter variable requirement is
                not met. So the URL of 'http://example.com/archive/test' will
                match the above route and set the year to 2006. This
                functionality may be altered in the future as it is being
                discussed at the moment of writing of this documentation.
            </note>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.rewritebase">
            <title>Base URL and subdirectories</title>

            <para>
                Unlike the original Router, RewriteRouter can be used in
                subdirectories. The original RewriteRouter's setRewriteBase()
                method is no longer available however. Instead the base URL
                will be automatically detected by Zend_Controller_Request_Http 
                (which proxies to Zend_Http_Request).
            </para>

            <para>
                Should rewrite base be detected incorrectly you can override it
                with your own base path with the help of Zend_Http_Request
                by calling the setBaseUrl() method (see <xref linkend="zend.controller.providedsubclasses.request.http" />).
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.default-routes">
            <title>Default routes</title>

            <para>
                Zend_Controller_RewriteRouter is preconfigured with two default
                routes. The first handles  your root URL and is mapped to
                indexAction of IndexController: so you have to provide them as
                outlined in the <xref linkend="zend.controller.getting-started" />
                (see <xref linkend="zend.controller.overview.defaultcontroller" />).
                The second default route is included to provide compatibility with
                the first version of the router. It will match URIs in the shape
                of <code>'controller/action'</code> and will also match any
                additional parameters appended to the URI by default.
            </para>

            <para>
                Default rules are configured as:
            </para>

            <programlisting role="php"><![CDATA[
// Add default route (for root url - '/')
$default = new Zend_Controller_Router_Route('', array('controller' => 'index', 'action' => 'index'));
$this->addRoute('default', $default);
        
// Route for Router v1 compatibility
$compat = new Zend_Controller_Router_Route(':controller/:action/*', array('controller' => 'index', 'action' => 'index'));
$this->addRoute('compat', $compat);]]></programlisting>

            <note>
                Zend_Controller_RewriteRouter is configured for backwards
                compatibility. It will automatically match <code>controller/action</code>
                URIs with additional parameters. The additional parameters do not
                require the addition of new routes unless they must have default values
                or variable requirements. These additional parameters will be accessible
                from the Zend_Controller_Action::_getParam method.
            </note>

        </sect3>    </sect2>

    <sect2 id="zend.controller.providedsubclasses.response.http">
        <title>Zend_Controller_Response_Http</title>

        <para>
            <code>Zend_Controller_Response_Http</code> is a response object
            suitable for use in an HTTP environment. It contains methods for
            setting, retrieving, and clearing headers, and the
            <code>__toString()</code> method sends all headers at once before
            returning the response content.
        </para>

        <para>
            <code>setHeader()</code> takes two arguments, a header type and the
            header value. A third, optional parameter, if passed and true, will
            force the new header to replace any other headers registered with
            that type.
        </para>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.response.cli">
        <title>Zend_Controller_Response_Cli</title>

        <para>
            <code>Zend_Controller_Response_Cli</code> is a response object
            suitable for use in an CLI environment. It has no methods for
            handling headers, and simply returns all body content when
            <code>__toString()</code> is invoked.
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->

