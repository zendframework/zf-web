<h2>ZF-1103: Cascading delete functionality is not recursive</h2>

<dl class="metadata">
    <dt>Issue Type:</dt>
    <dd>Bug</dd>

    <dt>Created:</dt>
    <dd>2007-03-21T16:56:51.000+0000</dd>

    <dt>Last Updated:</dt>
    <dd>2012-06-05T01:35:47.000+0000</dd>

    <dt>Status:</dt>
    <dd>Resolved</dd>

    <dt>Fix version(s):</dt>
    <dd><ul>        <li>1.11.12 (22/Jun/12)</li>
    </ul></dd>

    <dt>Reporter:</dt>
    <dd>
        None
                    </dd>

    <dt>Assignee:</dt>
    <dd>
                Adam Lundrigan (adamlundrigan)
            </dd>

    <dt>Tags:</dt>
    <dd><ul>        <li>Zend_Db_Table</li>
            <li>FixForZF1.12</li>
            <li>state:need-feedback</li>
            <li>zf-caretaker-adamlundrigan</li>
            <li>zf-crteam-review</li>
        </ul></dd>

    <dt>Related issues:</dt>
    <dd><ul>
        <li><a href="/issues/browse/ZF-12265">ZF-12265</a></li>
            <li><a href="/issues/browse/ZF-11810">ZF-11810</a></li>
        </ul></dd>

    <dt>Attachments:</dt>
    <dd><ul>
        <li><a href="/issues/secure/attachment/12554/Zend_Db-cascade-delete.diff">Zend_Db-cascade-delete.diff</a></li>
            <li><a href="/issues/secure/attachment/15116/ZF-1103_complete.patch">ZF-1103_complete.patch</a></li>
            <li><a href="/issues/secure/attachment/15077/ZF-1103_test.patch">ZF-1103_test.patch</a></li>
        </ul></dd>
</dl>

<div class="description">
    <h3>Description</h3>

    <div class="body">
        <p>Cascade delete now deletes only one level of data. For example:</p>

<p>table object:
  id
  parent
  name</p>

<p>data:
||id||parent||name||
|1|null|domain1|
|2|1|section1|
|3|2|item1|</p>

<p>$objects-&gt;find(1)-&gt;current()-&gt;delete() it deletes domain1 and section1 and not item1.
Probably issue is in _cascadeDelete method that deletes rows in dependent table using table-&gt;delete($where), not by selecting a rowset and calling -&gt;delete for each row.</p>

<p>In DBMS cascade operations affect all depended tables and their subtables.</p>

    </div>
</div>

<div class="comments">
    <h3>Comments</h3>

    <div class="comment">
        <p class="metadata">Posted by Bill Karwin (bkarwin) on 2007-03-22T12:22:26.000+0000</p> 
        <div class="body">
            <p>Assign to Bill Karwin.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Pelle Wessman (voxpelli) on 2007-09-24T15:15:04.000+0000</p> 
        <div class="body">
            <p>Came across this bug also when I removed a parent of another table which in turn was the parent of a third table from which the affected rows wasn't removed.</p>

<p>On row 887 of the Zend_Table_Abstract in version 1.0.1 within the function _cascadeDelete a row is constructed like this:</p>

<pre class="highlight"><code>

It should instead be constructed as something like this:
</code></pre>

<p>$toDelete = $this-&gt;fetchAll($where);
foreach($toDelete as $row) {
    $rowsAffected += $row-&gt;delete();
}
```</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Pelle Wessman (voxpelli) on 2007-09-24T15:17:48.000+0000</p> 
        <div class="body">
            <p>By the way - shouldn't this be flagged as a bug rather than an improvement?</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Pelle Wessman (voxpelli) on 2007-09-26T04:03:22.000+0000</p> 
        <div class="body">
            <p>Another effect of the current way of deleting rows in depending tables is that it bypasses eventual pre- and post-operations that may have been added to those tables row-classes. Is that an issue perhaps?</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Wil Sinclair (wil) on 2008-03-25T20:43:59.000+0000</p> 
        <div class="body">
            <p>Please categorize/fix as needed.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Wil Sinclair (wil) on 2008-04-18T13:11:49.000+0000</p> 
        <div class="body">
            <p>This doesn't appear to have been fixed in 1.5.0. Please update if this is not correct.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Rob Howard (rhoward) on 2008-07-22T17:34:51.000+0000</p> 
        <div class="body">
            <p>Seconding Pelle Wessman's comment regarding the status of this issue; this issue should be marked as a Bug, as the current method of cascading results in unexpected behaviour (ie. it behaves in a manner contrary to every other "cascade" operation I can think of, RDBMS or otherwise).</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Jaka Jancar (jaka) on 2008-11-21T01:53:58.000+0000</p> 
        <div class="body">
            <p>This indeed is a bug. I was 100% sure that it works like normal cascades in RDBMSs do, until reading it.</p>

<p>Cascades on the PHP level are also useful if you're using triggers in MySQL, because native MySQL cascades don't trigger them on cascaded changes.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Wil Sinclair (wil) on 2008-12-04T13:17:30.000+0000</p> 
        <div class="body">
            <p>Reassigning to Ralph since he's the new maintainer of Zend_Db</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Ralph Schindler (ralph) on 2009-01-09T13:34:06.000+0000</p> 
        <div class="body">
            <p>Ill attempt to confirm this with unit tests within 2 weeks.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Frank Groeneveld (frenkel) on 2009-04-17T23:54:30.000+0000</p> 
        <div class="body">
            <p>Ralph Schindler, did you confirm this?</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Ralph Schindler (ralph) on 2009-07-17T15:32:48.000+0000</p> 
        <div class="body">
            <p>Not confirmed yet.  But just a thought: what is to prevent circular references from being an issue?</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Konr Ness (konrness) on 2009-09-02T11:52:53.000+0000</p> 
        <div class="body">
            <p>Do you need more information to resolve this issue?</p>

<p>I'd be happy to provide some test cases or anything else you may need. I believe this to be a rather serious issue with Zend_Db_Table.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Ralph Schindler (ralph) on 2009-09-17T16:41:39.000+0000</p> 
        <div class="body">
            <p>Yes, can you provide a simple test case that demonstrates the problem? Do you know if it can be demonstrated with the existing database in the unit tests?</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by John Cokos (jcokos) on 2009-10-14T09:13:30.000+0000</p> 
        <div class="body">
            <p>I have the same issue.  Below is an example of  how you can replicate it ...</p>

<p>============================================================================</p>

<h1>The SQL Tables and some sample data:</h1>

<pre class="highlight"><code>
CREATE TABLE IF NOT EXISTS `testtable` (
  `rowid` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`rowid`)
);

CREATE TABLE IF NOT EXISTS testtable_sub (
  rowid int(11) NOT NULL AUTO_INCREMENT,
  testtable_id int(11),
  name varchar(255) DEFAULT NULL,
  PRIMARY KEY (`rowid`),
  KEY tts (testtable_id)
);


CREATE TABLE IF NOT EXISTS testtable_sub_sub (
  rowid int(11) NOT NULL AUTO_INCREMENT,
  testtable_sub_id int(11),
  name varchar(255) DEFAULT NULL,
  PRIMARY KEY (`rowid`),
  KEY ttss (testtable_sub_id)
);


CREATE TABLE IF NOT EXISTS testtable_sibling (
  rowid int(11) NOT NULL AUTO_INCREMENT,
  testtable_id int(11),
  name varchar(255) DEFAULT NULL,
  PRIMARY KEY (`rowid`),
  KEY ttsb (testtable_id)
);


INSERT INTO testtable VALUES( 1, "Person 1" );
INSERT INTO testtable VALUES( 2, "Person 2" );

INSERT INTO testtable_sibling VALUES( 3, 1, "Person 1 (sibling)" );
INSERT INTO testtable_sibling VALUES( 5, 2, "Person 2 (sibling)" );

INSERT INTO testtable_sub VALUES( 5, 1, "Person 1 (sub)" );
INSERT INTO testtable_sub VALUES( 7, 2, "Person 2 (sub)" );

INSERT INTO testtable_sub_sub VALUES( 1, 5, "Person 1 (sub sub 1)" );
INSERT INTO testtable_sub_sub VALUES( 2, 5, "Person 1 (sub sub 2)" );
INSERT INTO testtable_sub_sub VALUES( 3, 7, "Person 2 (sub sub 2)" );
</code></pre>

<p>============================================================================</p>

<h1>The Models/Classes (I have them in separate files, but am just copying/pasting here for speed)</h1>

<pre class="highlight"><code>
&lt;?php
class Testtable extends Table
{
    # This table
    protected $_name = 'testtable';
    protected $_primary = array( 'rowid' );
    protected $_sequence = true;

    # Dependents
    protected $_dependentTables = array( 'TesttableSibling','TesttableSub' );

    # References
    protected $_referenceMap = array(

    );
}

?&gt;

&lt;?php
class TesttableSibling extends DB_Table_Abstract
{
    # This table
    protected $_name = 'testtable_sibling';
    protected $_primary = array( 'rowid' );
    protected $_sequence = true;

    # Dependents
    protected $_dependentTables = array();

    # References
    protected $_referenceMap = array(
        'TT'        =&gt; array(
            'columns'       =&gt; 'testtable_id',
            'refTableClass' =&gt; 'Testtable',
            'refColumns'    =&gt; 'rowid',
            'onDelete'      =&gt; self::CASCADE,
            'onUpdate'      =&gt; self::CASCADE,
        ),
    );


}

?&gt;

&lt;?php
class TesttableSub extends DB_Table_Abstract
{
    # This table
    protected $_name = 'testtable_sub';
    protected $_primary = array( 'rowid' );
    protected $_sequence = true;

    # Dependents
    protected $_dependentTables = array( 'TesttableSubSub' );

    # References
    protected $_referenceMap = array(
        'TT'        =&gt; array(
            'columns'       =&gt; 'testtable_id',
            'refTableClass' =&gt; 'Testtable',
            'refColumns'    =&gt; 'rowid',
            'onDelete'      =&gt; self::CASCADE,
            'onUpdate'      =&gt; self::CASCADE,
        ),
    );

}

?&gt;

&lt;?php
class TesttableSubSub extends DB_Table_Abstract
{
    # This table
    protected $_name = 'testtable_sub_sub';
    protected $_primary = array( 'rowid' );
    protected $_sequence = true;

    # Dependents
    protected $_dependentTables = array();

    # References
    protected $_referenceMap = array(
        'TT'        =&gt; array(
            'columns'       =&gt; 'testtable_sub_id',
            'refTableClass' =&gt; 'TesttableSub',
            'refColumns'    =&gt; 'rowid',
            'onDelete'      =&gt; self::CASCADE,
            'onUpdate'      =&gt; self::CASCADE,
        ),
    );


}

?&gt;
</code></pre>

<p>============================================================================</p>

<h1>Test Case</h1>

<pre class="highlight"><code>
    $TestTable = new Testtable();

    $record = $TestTable-&gt;getRecord( array (
        "rowid" =&gt; $this-&gt;view-&gt;params['oldid']
    ) );

    $record-&gt;delete();

</code></pre>

<p>Create an object of TestTable, grab one row (find by rowid) and then call $row-&gt;delete()</p>

<p>It will delete the record from testtable, testtable_sub and testtable_sibling (both are immediate children of testttable), but any records in testtable_sub_sub, which is a child of testtable_sub are not deleted as you would expect them to be, following the deletion of their parent rows from testtable_sub by the cascade operation.</p>

<p>If you set these same tables up in mySQL as INNODB, using Foreign Keys and cascading deletes, everything happens as it should when you delete the parent record ... would be nice to have reliable functionality at the Zend Level as well for those cases where you cannot rely on the DB to think for you.</p>

<p>HTH, John</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Ralph Schindler (ralph) on 2009-12-30T20:56:51.000+0000</p> 
        <div class="body">
            <p>Attachment is against trunk.</p>

<p>To use this feature, set the 'onDelete' key of any reference map element to self::CASCADE_RECURSE instead of self::CASCADE.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Konr Ness (konrness) on 2010-01-01T19:27:54.000+0000</p> 
        <div class="body">
            <p>Changing the _getPrimaryKey() function in Zend_Db_Table_Row_Abstract to have public scope instead of protected is problematic because the Zend coding standard's naming convention does not allow an underscore to preceed a public method's name.</p>

<p>Perhaps you change the _getPrimaryKey() back to protected and add a public getPrimaryKey() that calls the protected function?</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Ralph Schindler (ralph) on 2010-01-02T12:05:26.000+0000</p> 
        <div class="body">
            <p>I can do that, yes. We do have some places in ZF that have public underscored methods, they are mainly there as a way to "enforce" or demonstrate that they are to be used internally only.  Imagine if PHP had class level (or namespace visibility).</p>

<p>But I agree with you, and I can change this.  I guess it's not a big deal if getPrimaryKey() is visibly available to consumers of the class.</p>

<p>How does it work for you though? :)</p>

<p>-ralph</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Konr Ness (konrness) on 2010-01-02T22:48:17.000+0000</p> 
        <div class="body">
            <p>In my initial tests, the recursive deletes are working on my test data.</p>

<p>Two Minor Changes:
1) There are three typos in the comments, both with the spelling of CASCADE. You have spelled it CASECADE.
2) The method comment for _cascadeDelete says "Called by parent table's class during delete() method.", but it should actually be something along the lines of:
  Called by table row during delete() method, and the parent table's class during _cascadeDelete() method for recursive cascading deletes.</p>

<hr /><p>I did have one possibly unrelated question/issue. I tried creating a table relationship where the refColumn defined in the child table's referenceMap is not one of the parent table's primary keys. A cascading and/or cascadingRecursive delete does not work because when the table's _cascadeDelete() method is called, only the primary keys are passed as the second parameter. I'm wondering why only the primary keys were sent and not all of the data. This would allow the following scenario:</p>

<pre class="highlight"><code>
DROP TABLE IF EXISTS `profiles`;
CREATE TABLE `profiles` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(30) NOT NULL,
  `photoId` int(11) NOT NULL,
  PRIMARY KEY  (`id`),
  KEY `photo` (`photoId`)
);

INSERT INTO `profiles` (`id`, `name`, `photoId`) VALUES
(101, 'Profile #1', 201),
(102, 'Profile #2', 202);

DROP TABLE IF EXISTS `photos`;
CREATE TABLE `photos` (
  `id` int(11) NOT NULL auto_increment,
  `title` varchar(50) NOT NULL,
  `path` varchar(255) NOT NULL,
  PRIMARY KEY  (`id`)
);

INSERT INTO `photos` (`id`, `title`, `path`) VALUES
(201, 'Profile #1 Photo', '/images/one.jpg'),
(202, 'Profile #2 Photo', '/images/two.jpg');
</code></pre>

<p>When a profile is deleted, I want the corresponding profile photo (stored in photos table) deleted as well.</p>

<p>Here's my models:</p>

<pre class="highlight"><code>
&lt;?php
class Application_Model_Profiles extends Zend_Db_Table_Abstract
{
    protected $_name    = 'profiles';

    protected $_dependentTables = array(
        'Application_Model_Photos',
    );

}

&lt;?php
class Application_Model_Photos extends Zend_Db_Table_Abstract
{
    /** Table name */
    protected $_name    = 'photos';

    protected $_referenceMap    = array(
        'Profile' =&gt; array(
            'columns'           =&gt; 'id',
            'refTableClass'     =&gt; 'Application_Model_Profiles',
            'refColumns'        =&gt; 'photoId',
            'onDelete'          =&gt; self::CASCADE_RECURSE,
        ),
    );
}
</code></pre>

<p>The reason I organized the data like this is to allow several different entities (profiles, albums, users, groups, etc.) to store their photo in one table. The cascading deletes, however, do not work because the photoId column from the Photos table doesn't exist in the _cascadeDelete method because only the profile's ID column is passed.</p>

<p>I know this is off-topic for the recursive cascading deletes, but perhaps this new capability could be added simultaneously.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Edward &quot;Sonny&quot; Savage (sonnysavage) on 2010-06-21T14:34:43.000+0000</p> 
        <div class="body">
            <p>I ran into this issue. My solution is a bit simpler than the proposed one. It's posted on <a href="http://stackoverflow.com/questions/3023809/zend-framework-problem-with-database-table-recursive-cascading-deletes">Stack Overflow</a>. My solution only touches the {{_cascadeDelete}} function.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Edward &quot;Sonny&quot; Savage (sonnysavage) on 2010-06-23T08:14:05.000+0000</p> 
        <div class="body">
            <p>I see a steady trend of this getting put off.  What is needed to get this included in a release?  It's a bug.  True, recursive, cascading deletes are not performed.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Adam Lundrigan (adamlundrigan) on 2011-10-31T19:09:43.000+0000</p> 
        <div class="body">
            <p>Is there any reason this never made it into the framework?</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Adrian Imfeld (adriani) on 2012-01-25T10:07:39.000+0000</p> 
        <div class="body">
            <p>I tested the patch suggested by Pelle Wessmann and it worked for me. +1 for integrating into the framework.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Adam Lundrigan (adamlundrigan) on 2012-05-09T23:53:53.000+0000</p> 
        <div class="body">
            <p>Attached reproducing test case which uses the single-table schema proposed by the original ticket creator:</p>

<pre class="highlight"><code>
CREATE TABLE `zfalt_cascade_recursive` (
  `item_id` int(11) NOT NULL,
  `item_parent` int(11) DEFAULT NULL,
  `item_data` varchar(100) NOT NULL,
  PRIMARY KEY (`item_id`)
);

INSERT INTO `zfalt_cascade_recursive` (`item_id`, `item_parent`, `item_data`) VALUES
(1, NULL, '1'),
(2, 1, '1.2'),
(3, 1, '1.3'),
(4, 3, '1.3.4'),
(5, 3, '1.3.5'),
(6, NULL, '6');
</code></pre>

<p>PHPUnit Result:</p>

<pre class="highlight"><code>
PHPUnit 3.4.15 by Sebastian Bergmann.

Zend Framework
 Zend Framework - Zend
   Zend Framework - Zend_Db
     Zend_Db_Table_MysqliTest
   F
  
   Zend_Db_Table_Pdo_MysqlTest
   F
  
   Zend_Db_Table_Pdo_SqliteTest
   F
  
Time: 10 seconds, Memory: 418.00Mb

There were 3 failures:

1) Zend_Db_Table_MysqliTest::testTableCascadeRecurseDelete
Failed asserting that 
Zend_Db_Table_Row Object ( item_id = 4 )
 is null.

/var/www/ZFv1/trunk/tests/Zend/Db/Table/TestCommon.php:1643

2) Zend_Db_Table_Pdo_MysqlTest::testTableCascadeRecurseDelete
Failed asserting that 
Zend_Db_Table_Row Object ( item_id = 4 )
 is null.

/var/www/ZFv1/trunk/tests/Zend/Db/Table/TestCommon.php:1643

3) Zend_Db_Table_Pdo_SqliteTest::testTableCascadeRecurseDelete
Failed asserting that 
Zend_Db_Table_Row Object ( item_id = 4 )
 is null.

/var/www/ZFv1/trunk/tests/Zend/Db/Table/TestCommon.php:1643

FAILURES!
Tests: 3, Assertions: 39, Failures: 3.
</code></pre>

<p>As you can see, it only deletes the parent row and the first level dependent rowset.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Adam Lundrigan (adamlundrigan) on 2012-05-28T21:26:14.000+0000</p> 
        <div class="body">
            <p>Updated title and description</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Adam Lundrigan (adamlundrigan) on 2012-05-29T02:08:40.000+0000</p> 
        <div class="body">
            <p>Attached fix appears to work as expected.  After applying the patch, change the onDelete parameter value in the file {{tests/Zend/Db/Table/_files/My/ZendDbTable/TableCascadeRecursive.php}} from {{self::CASCADE}} to {{self::CASCADE_RECURSE}} and the tests will pass.</p>

<p>A similar fix and unit test suite will need to be implemented for {{onUpdate}} as well.</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Adam Lundrigan (adamlundrigan) on 2012-05-30T11:43:08.000+0000</p> 
        <div class="body">
            <p>Attached completed patch for onDelete recursive cascade (fix + unit test + manual page update).  Will open a separate ticket to implement similar fix for onUpdate</p>

        </div>
    </div>
        <div class="comment">
        <p class="metadata">Posted by Rob Allen (rob) on 2012-05-30T12:52:40.000+0000</p> 
        <div class="body">
            <p>Fixed in SVN r24831.</p>

        </div>
    </div>
    </div>

